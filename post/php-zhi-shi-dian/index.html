<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>php知识点 | best7l</title>
<link rel="shortcut icon" href="https://wudengli.github.io/favicon.ico?v=1634873811556">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://wudengli.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="php知识点 | best7l - Atom Feed" href="https://wudengli.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="模拟面试
Php


php数组
in_array
is_array
array_merge
array_push          从尾部插入
array_pop           从尾部移除
array_shift         从..." />
    <meta name="keywords" content="php" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://wudengli.github.io">
  <img class="avatar" src="https://wudengli.github.io/images/avatar.png?v=1634873811556" alt="">
  </a>
  <h1 class="site-title">
    best7l
  </h1>
  <p class="site-description">
    Talk is cheap, give me the code!
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              php知识点
            </h2>
            <div class="post-info">
              <span>
                2021-09-13
              </span>
              <span>
                33 min read
              </span>
              
                <a href="https://wudengli.github.io/tag/T4PpWBu_a/" class="post-tag">
                  # php
                </a>
              
            </div>
            
              <img class="post-feature-image" src="https://wudengli.github.io/post-images/php-zhi-shi-dian.JPG" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h1 id="模拟面试">模拟面试</h1>
<h3 id="php">Php</h3>
<ul>
<li>
<p>php数组</p>
<pre><code>in_array
is_array
array_merge
array_push          从尾部插入
array_pop           从尾部移除
array_shift         从头部移除
array_unshift       从头部插入
array_map
array_keys
array_key_exists
array_key_first
array_key_last
array_values
array_column
array_diff          获取两个数组的差集
array_intersect     获取两个数组的交集
array_chunk         将数组分块
array_reduce
count
foreach
explode
join
sort
</code></pre>
</li>
<li>
<p>oop面向对象</p>
<pre><code>1.封装:将对象信息通过访问权限修饰符隐藏,不允许外部直接访问.
2.继承:子类继承父类的方法与属性.
3.多态:方法重写和重载
</code></pre>
</li>
<li>
<p>php 超全局变量</p>
<pre><code>$GLOBAL
$_GET
$_POST
$_FILES
$_COOKIE
$_SESSION
$_SERVER
$_REQUEST
$_ENV
</code></pre>
</li>
<li>
<p>魔术方法</p>
<pre><code>__construct
__destruct
__call
__callStatic
__get
__set
__isset
__unset
__sleep
__toString
__clone
__wakeup
</code></pre>
</li>
<li>
<p>魔术常量</p>
<pre><code>__FILE__
__LINE__
__DIR__
__CLASS__
__METHOD__
__FUNCTION__
</code></pre>
</li>
<li>
<p>数据结构,基础算法,设计模式</p>
<ul>
<li>
<p>数据结构</p>
<ul>
<li>
<p>数组</p>
</li>
<li>
<p>链表</p>
</li>
<li>
<p>栈</p>
<p>array_unshift()从头部入队</p>
<p>array_shift()从头部移除</p>
<p>array_pop()出队</p>
</li>
<li>
<p>队列</p>
<p>array_push()从尾部入队</p>
<p>array_pop()出队</p>
</li>
<li>
<p>树</p>
<ul>
<li>二叉树</li>
<li>b+树</li>
</ul>
</li>
</ul>
</li>
<li>
<p>基础算法</p>
<ul>
<li>
<p>二分查找</p>
<pre><code>function search(&amp;$arr,$number,$left,$right)
{
    /**
     * 先计算中位数
     * 随后将数组中的值与中位数进行比较
     * 若在中位数的右侧,则舍去左边部分 $left + 1
     * 若在中位数的左侧,则舍去右边部分 $right -1
     * 若都不在则返回中位数
     */
    $mid = intval($left + $right)/2
    
    if($left &gt; $right)
    {
       return -1;
    }
    
    if($number &gt; $arr[$mid])
    {
        search($arr,$number,$mid+1,$right);
    } 
    else if($number &lt; $arr[$mid])
    {
        search($arr,$number,$left,$mid -1);
    }
    else
    {
        return $mid;
    }
}
</code></pre>
</li>
<li>
<p>插值查找</p>
<pre><code>function insertSort($arr) {
    $len = count($arr);
    for($i = 1 ;$i &lt; $len; $i++)
    {
         $key = $arr[$i];
         $pos = $i
         
         while($pos &gt; 0 &amp;&amp; $arr[$pos -1] &gt; $key)
         {
              $arr[$pos] = $arr[$pos - 1];
              $pos = $pos-1
         }
         $arr[$pos] = $key;
    }
    return $arr;
}
</code></pre>
</li>
<li>
<p>冒泡排序</p>
<pre><code>function bubbleSort($arr)
{
    $len = count($arr);
    if($len == 1) return $arr;
    for($i = 0;$i &lt; $len;$i++){
       $isOver = false
       for($j = 0; $j &lt; $len - $i -1;$j++){
            if($arr[$j] &gt; $arr[$j+1]){
                $temp = $arr[$j];
                $arr[$j] = $arr[$j+1];
                $arr[$j+1] = $temp
                $isOver = true;
            }
       }
       if(!$isOver){
           break;
       }
    }
    return $arr;
}
</code></pre>
</li>
<li>
<p>快速排序</p>
<pre><code>function quickSort($arr)
{
     $len = count($arr);
     $mid = $arr[0];
     $left = [];
     $right = [];
     for($i= 1;$i&lt;$len;$i++){
          if($arr[$i]&gt;$mid){
            $right[] = $arr[$i];
          }else{
            $left[] = $arr[$i];
          }
     }
     $left = quickSort($left);
     $right = quickSort($right);
     return array_merge($left,[$mid],$right);
}
</code></pre>
</li>
<li>
<p>选择排序</p>
<pre><code>function selectSort($arr)
{
    $len = count($arr);
    for($i = 0;$i&lt;$len-1;$i++){
       $min = $i;
       for($j = $i + 1;$i&lt;$len;$j++){
           if($arr[$i] &gt; $arr[$j]){
              $min = $j
           }
       }
       if($i != $min){
          $temp = $arr[$i];
          $arr[$i] = $arr[$min];
          $arr[$min] = $temp;
       }
    }
    return $arr;
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>设计模式</p>
<ul>
<li>
<p>单例模式</p>
<pre><code>class single
{
   private static $instance;
   
   private function __construct()
   {
   
   }
   
   public static function getInstance(){
       if(!(self::$instance instanceof self)){
            self::$instance = new self;
       }
       return $self::$instance;
   }
   
   private function __clone()
   {
   
   }
}
</code></pre>
</li>
<li>
<p>工厂模式</p>
<pre><code>class Factory
{
      private static $nameList = [
           'a' =&gt; APP\Lib\A,
           'b' =&gt; APP\Lib\B,
      ];

      public static function GetObject($className){
          $obj = new $nameList[self::className]();
          return $obj;
      }
}
</code></pre>
</li>
<li>
<p>策略模式</p>
<pre><code>interface Base
{
    public function run();
}

class A ipmlements Base
{
    public function run(){
       reuturn 'aaaa';
    }
}

class B ipmlements Base
{
    public function run(){
       reuturn 'bbbb';
    }
}

class C ipmlements Base
{
    public function run(){
       reuturn 'cccc';
    }
}

class Ci {
    public $sub;

    public function __construct(Base $base)
    {
          $this-&gt;sub = $base;
    }
    
    public function test()
    {
         $this-&gt;sub-&gt;run();
    }
}

$test = new Ci(new A)
$test-&gt;test();
</code></pre>
</li>
<li>
<p>门脸模式</p>
<pre><code>class SubSysOne
{
    function methodone()
    {
        return 'rethod one';
    }
}

class SubSysTwo
{
    function methodtwo()
    {
        return 'rethod two';
    }
}

class SubSysTree
{
    function methodthree()
    {
        return 'rethod three';
    }
}

class Facade {
   private $subSystemOne = null;
   private $subSystemTwo = null;
   private $subSystemThree = null;
   
   public function __contruct()
   {
       $this-&gt;subSystemOne = new SubSysOne;
       $this-&gt;subSystemTwo = new SubSysTwo;
       $this-&gt;subSystemThree = new SubSysThree;
   }

   public function methodA()
   {
        $this-&gt;subSystemOne-&gt;methodone();
   }
   
   public function methodB()
   {
        $this-&gt;subSystemOne-&gt;methodtwo();
   }
   
   public function methodC()
   {
        $this-&gt;subSystemOne-&gt;methodthree();
   }
}
</code></pre>
</li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<p>网络协议(TCP/IP, HTTP)</p>
<pre><code>-- 三次握手,四次回收
--网络七层
  -物理层
  -数据链路层
  -网络层
  -传输层
  -会话层
  -表示层
  -应用层
  
-IP协议属于网络层
-TCP协议属于传输层
-RPC属于会话层

一、什么是TCP连接的三次握手
第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认;
第二次握手：服务器收到syn包，必须确认客户的SYN(ack=j+1)，同时自己也发送一个SYN包(syn=k)，即SYN+ACK包，此时服务器进入SYN_RECV状态;
第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。
握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。
理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。
断开连接时服务器和客户端均可以主动发起断开TCP连接的请求，断开过程需要经过“四次握手”(过程就不细写了，就是服务器和客户端交互，最终确定断开)
</code></pre>
</li>
<li>
<p>swoft</p>
<pre><code>
</code></pre>
</li>
<li>
<p>Restful API</p>
<pre><code>
</code></pre>
</li>
<li>
<p>Nginx</p>
<pre><code>nginx 是一个高性能的HTTP和反向代理服务器

使用epoll 的IO模型

工作进程一般是cpu核心数的两倍

开启高效传输模式 sendfile on

连接超时时间

fastcgi 调优
 -应答时间调整
 -接收超时时间调整

proxy_cache / fastcgi_cache

若其他网站引用我们网站的静态资源，我们可以在nginx 上添加防盗链/*-
</code></pre>
</li>
<li>
<p>cgi与fastcgi与fpm等</p>
<pre><code>cgi 是通用网关接口,用于接收客户端的所有请求,转化为服务器能运行的代码再返回给客户端,在处理完进程后会kill进程

fast-cgi是cgi 的升级版,常驻进程,

php-cgi是fast-cgi 的实现,提供了进程管理功能,一个master进程,多个work进程,每个work进程都配备了一个php解释器.


--运行流程
www.example.com
        |
        |
      Nginx
        |
        |
路由到www.example.com/index.php
        |
        |
加载nginx的fast-cgi模块
        |
        |
fast-cgi监听127.0.0.1:9000地址
        |
        |
www.example.com/index.php请求到达127.0.0.1:9000
        |
        |
php-fpm 监听127.0.0.1:9000
        |
        |
php-fpm 接收到请求，启用worker进程处理请求
        |
        |
php-fpm 处理完请求，返回给nginx
        |
        |
nginx将结果通过http返回给浏览器
        

</code></pre>
</li>
<li>
<p>rpc</p>
<pre><code>基于会话层的传输协议
</code></pre>
</li>
<li>
<p>php 的反射机制</p>
<pre><code>
</code></pre>
</li>
<li>
<p>递归</p>
</li>
<li>
<p>php四种运行模式</p>
<pre><code>-CGI
 通用网关接口,有多少个连接就有多少个cgi子进程,效率低
-fast-cgi
 
-cli
-DLL模块
</code></pre>
</li>
<li>
<p>上传文件</p>
<pre><code class="language-php">&lt;?php
$uploaddir = '/var/www/uploads/';
$uploadfile = $uploaddir . basename($_FILES['userfile']['name']);

echo '&lt;pre&gt;';
if (move_uploaded_file($_FILES['userfile']['tmp_name'], $uploadfile)) {
    echo &quot;File is valid, and was successfully uploaded.\n&quot;;
} else {
    echo &quot;Possible file upload attack!\n&quot;;
}

echo 'Here is some more debugging info:';
print_r($_FILES);

print &quot;&lt;/pre&gt;&quot;;

?&gt;
</code></pre>
</li>
<li>
<p>DDD领域设计</p>
<pre><code>接入层
 -内部rpc服务
 -对外api服务
业务层
 -业务层insterface调用,模块独立化
服务层
 -controller代码处理逻辑
基础设施层
 -系统局部与全局基础设施搭建
</code></pre>
</li>
</ul>
<h3 id="mysql">Mysql</h3>
<ul>
<li>索引优化</li>
<li>sql注入</li>
<li>查询优化
<ul>
<li>explain</li>
</ul>
</li>
<li>存储优化</li>
<li>事务等待</li>
<li>分库分表</li>
<li>读写分离</li>
</ul>
<h3 id="redis">Redis</h3>
<ul>
<li>业务场景
<ul>
<li>消息队列</li>
<li>缓存</li>
</ul>
</li>
<li>解决秒杀</li>
<li>数据结构
<ul>
<li>字符串</li>
<li>列表</li>
<li>哈希</li>
<li>有序集合</li>
<li>无序集合</li>
</ul>
</li>
</ul>
<h3 id="docker">Docker</h3>
<ul>
<li>
<p>基本指令</p>
<pre><code>
</code></pre>
</li>
<li>
<p>什么是docker</p>
</li>
<li>
<p>docker 与虚拟机有什么不同</p>
</li>
<li>
<p>什么是docker镜像</p>
</li>
<li>
<p>什么是docker容器</p>
</li>
<li>
<p>docker有哪几种状态</p>
</li>
</ul>
<h3 id="laravel">Laravel</h3>
<ul>
<li>中间件的实现原理</li>
<li>优缺点以及与其他框架比对</li>
<li>容器 循环依赖</li>
<li>服务优化</li>
<li>sso单点登陆(jwt)</li>
<li>服务提供者</li>
<li>门脸</li>
<li>领域设计</li>
<li>Elastic search</li>
</ul>
<h3 id="http与nginx">http与nginx</h3>
<ul>
<li>http与https</li>
<li>IP/TCP协议</li>
<li>nginx基本配置及优化</li>
</ul>
<h3 id="kafka与rabbitmq">kafka与Rabbit<em>MQ</em></h3>
<ul>
<li>消息队列搭建</li>
</ul>
<h3 id="linux-与-shell">Linux 与 Shell</h3>
<ul>
<li>常用指令
<ul>
<li>查看进程  ps -ef | grep deadloop.php</li>
<li>查看网关  route -n</li>
<li>终止进程  pkill -9 pid</li>
<li>关机重启  reboot(重启)   halt(立即关机)</li>
<li>查找文件  find [范围] [-条件] [文件名]</li>
<li>创建目录 mkmir [文件夹名称]</li>
<li>创建文件 touch [文件名]</li>
<li>删除文件夹及文件 rm -rf [dir1]</li>
<li>压缩文件 tar -zcvf [文件名] [压缩路径]</li>
<li>解压文件 tar -zxvf [文件名]</li>
<li>移动文件 mv [文件名]</li>
<li>复制文件 cp [原文件名] [新文件名加路径]</li>
<li>创建用户 useradd [用户名]          passwd [用户名]</li>
<li>切换登陆用户 su 用户名</li>
<li>查看目录 ls</li>
<li>进入目录 cd [文件名]</li>
<li>删除文件 rm -f [文件名]</li>
<li>删除目录 rm -r [文件夹]</li>
<li>定时任务 crontab</li>
<li>添加文件权限</li>
<li>ping</li>
<li>ifconfig</li>
<li>wget</li>
<li>yum</li>
</ul>
</li>
</ul>
<h3 id="vue">Vue</h3>
<h3 id="golang">Golang</h3>
<ul>
<li>基本语法</li>
</ul>
<p>PHP 相关</p>
<ul>
<li>平常都使用的什么框架？Laravel 和 ThinkPHP 框架的区别？</li>
</ul>
<pre><code>共同点：都支持composer

不同点：1.laravel拥有中间件，tp拥有初始化函数_interlize
       2.laravel提交表单有csrf验证, tp需要手动完成防跨站请求的代码
       3.渲染方式不同,laravel中是return view(),tp中是$this-&gt;display();
       4.laravel内置了hash加密,tp则是md5()加密
       5.laravel可以使用php artisan migrate命令建表.laravel有专用的tinker直接与应用进行交互,建立模型建表都可以用artisan
       6.laravel拥有blade模板
       7.laravel必须定义路由,tp的请求路径则是请求类与请求方法拼接
       
 tp是国人开发,MVC风格也比较适合国人思想,
</code></pre>
<ul>
<li>laravel效率怎么样?有没有优化过laravel框架?</li>
</ul>
<pre><code>laravel 由于每次请求都要加载一系列的服务及配置,所以性能方面会低很多,但是通过一些优化,性能会提升一下.
1.缓存路由 php artisan route:cache
2.优化composer 自动加载
3.缓存配置文件 php artisan config:cache
4.关闭debug
5.删除缓存文件php artisan optimize
</code></pre>
<ul>
<li>Laravel 常用到的功能有哪些？Laravel 依赖注入实现的原理是怎么样的？</li>
</ul>
<pre><code>dd()
artisan
migrate 建表
定时任务
集合
缓存
路由
模型orm

一个类需要依赖另外一个类来实现功能, 利用了php的反射机制来构造
</code></pre>
<ul>
<li>Swoole 你用到了哪些功能？对协程这一块了解吗？</li>
</ul>
<p>能说说 PHP 的生命周期吗？传统的 php-fpm 模式和 swoole 有什么区别？</p>
<p>在项目中都是怎么用 hyperf 的？了解 hyperf 中的依赖注入实现原理吗？使用 hyperf 中的类是怎么实现的，是通过注解引入吗？</p>
<p>说说你在项目中使用到的 PHP 函数，任意说几个以及它的功能？</p>
<pre><code>--string

--array

--sort

--file
</code></pre>
<ul>
<li>PHP 的垃圾回收机制是怎么样的？</li>
</ul>
<pre><code>php中的变量存储在变量容器zval中，zval中除了存储变量类型和值外，还有is_ref和refcount字段。refcount表示指向变量的元素个数，is_ref表示变量是否有别名。如果refcount为0时，就回收该变量容器。如果一个zval的refcount减1之后大于0，它就会进入垃圾缓冲区。当缓冲区达到最大值后，回收算法会循环遍历zval，判断其是否为垃圾，并进行释放处理。/*
</code></pre>
<ul>
<li>PHP5 的版本和 PHP7 之间有哪些区别？对 PHP8 了解吗，任意说说其中的新特性？</li>
</ul>
<pre><code>1.性能提升, php7比php5性能提升了两倍
2.php7新增了函数返回类型声明及标量类型申明
3.php7新增了匿名类
4.php7中if条件中的数据key若不存在会直接报错,而php5则直接返回false
5.php7中新增了比较运算符
</code></pre>
<p>说说 php-fpm 与 NGINX 工作原理是怎么样的？</p>
<p>cgi 与 fast_cgi 关系是怎么样的？</p>
<pre><code>
</code></pre>
<p>isset、empty 和 is_null 区别是怎么样的？如果传递一个 null，该三个函数分别返回什么？</p>
<pre><code>false,false,true
isset 表示变量是否设置, 当传递 false null 0 空串 empty会返回true反之为false ,is_null 用于判断该参数是否为null 类型
</code></pre>
<p>require_once 与 include_once，require 与 include 的区别？为什么一个是警告一个是致命错误？</p>
<pre><code>require 在执行过程中若出现异常则会抛出一个致命错误,中断后续的程序 , 而include在执行时出现异常则会报一个wating警告,继续执行后面的代码.

require_once 与 include_once 表示只执行一次, 不重复引入
</code></pre>
<p>php-fpm 的工作模式？进程数量配置依据是什么？</p>
<p>说说 PHP 数组中的数据结构是怎么样的？</p>
<p><strong>Redis 相关</strong></p>
<ul>
<li>
<p>平常使用 Redis 都是在哪些场景？</p>
<ul>
<li>5大数据类型
<ul>
<li>字符串</li>
<li>列表</li>
<li>哈希</li>
<li>有序集合</li>
<li>无序集合</li>
</ul>
</li>
<li>用于缓存
<ul>
<li>加载权限列表</li>
</ul>
</li>
<li>为的是服务无状态
<ul>
<li>因为http 是无状态协议</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Redis 是单线程还是多线程?</p>
<ul>
<li>无论什么版本，工作线程就是一个</li>
<li>6.x版本出现了IO多线程</li>
</ul>
</li>
<li>
<p>遇到过Redis缓存穿透吗？</p>
<ul>
<li>穿透：redis 没有数据，直接穿透到mysql</li>
<li>避免无效请求</li>
<li>布隆过滤器：过滤掉缓存中与数据库中都不存在的数据</li>
</ul>
</li>
<li>
<p>遇到过Redis缓存击穿吗？</p>
<ul>
<li>击穿：添加互斥锁, 当串行在redis中为获取到key，那么会直接请求到数据库，这个时候，如果在数据库返回null时，那么后续在redis中没有的key将会进行取锁操作，没有取到所的将sleep，取到锁的将访问数据库。为的就是减少数据库操作。抢上的DB O(1)</li>
</ul>
</li>
<li>
<p>遇到过Redis 雪崩吗?请简述一下</p>
<ul>
<li>雪崩: 将缓存数据过期时间设置为随机, 设置热点数据永不过期.</li>
</ul>
</li>
<li>
<p>缓存是如何回收的(删除过期key)?</p>
<ul>
<li>redis 无用的key,在请求时判断是否i已经过期</li>
</ul>
</li>
<li>
<p>如何进行缓存预热</p>
<ul>
<li>如何先提前部署缓存数据</li>
<li>规避差集(没有缓存的数据),</li>
</ul>
</li>
<li>
<p>数据库与缓存不一致?</p>
<ul>
<li>我们可以使用分布式事务来解决(不推荐)</li>
</ul>
</li>
<li>
<p>简述一下主从不一致的问题?</p>
<ul>
<li>redis 是缓存, 更倾向于稍微的有时差</li>
<li>减少DB操作</li>
</ul>
</li>
<li>
<p>简述下主从不一致的问题?</p>
<ul>
<li>redis 是默认弱一致性的</li>
<li>锁不能用主从</li>
</ul>
</li>
<li>
<p>Redis 的持久化有哪几种？有什么区别？实现的原理是怎样的？</p>
<pre><code>1. AOF
2. RDB
</code></pre>
</li>
</ul>
<p>Redis 的事务了解吗？事务都有哪些注意的地方？</p>
<p>Redis 都有哪些数据类型？你是怎么选择数据类型的？底层的数据结构是怎么样的？</p>
<p>Redis 能够实现命令批处理吗？</p>
<p>Redis 的哨兵机制了解吗？实现原理是怎么样的？</p>
<p>Redis 的主从复制实现原理是怎么样的？如何保证数据一致性？数据延迟又该如何处理？</p>
<p>利用 Redis 如何实现队列功能？</p>
<p>消息发布与订阅有使用过吗？怎么使用的？中间又遇到过什么问题吗？</p>
<p>如何解决缓存穿透、击穿和雪崩问题？</p>
<p>Redis 作为一个内存型数据库，如何更好的解决内存的占用？</p>
<p>Redis 与 memcached 的区别？什么时候会选择 memcached？</p>
<pre><code>redis相比与memcached 更适合做存储
memcached因为数据结构是key-value的形式适合做缓存
</code></pre>
<p>MySQL<br>
列举几个 MySQL 索引失效的情况？该如何优化这些情况？</p>
<p>MySQL 索引都有哪些？InnoDB 索引是用的什么数据结构，为什么使用这种数据结构？</p>
<pre><code>全文索引
 -- 用于文章
唯一索引
 -- 主键索引
 -- 唯一索引
联合索引
 -- 当where 条件中为联合查询时,使用联合索引
普通索引
 -- 用于提高查询效率
</code></pre>
<p>MySQL设计规范? 常见的设计小问题?</p>
<p>MySQL 主从复制是如何实现的？如果从节点挂了，重新启动从节点，如何保持数据一致性？如何解决数据同步延迟问题？</p>
<p>说说你优化 SQL 语句的几种思路有哪些？</p>
<p>说说 MySQL 中的锁有哪些？之间的区别？</p>
<p>MySQL 中的事务了解吗？说说其 4 大特性？</p>
<p>事务中隔离性，有几种情况？这几种情况分别会产生什么问题？</p>
<p>MySQL 中 MVVC 实现的原理是怎么样的？</p>
<p>mongodb 与 mysql 的关系，为什么日志系统会选择 mongodb？</p>
<p>RabbitMQ<br>
主要使用的场景在哪些地方？</p>
<p>工作模式都有哪些？之间的区别是怎么样的？</p>
<p>如何保证消息的可靠性？</p>
<p>日志存储在 RabbitMQ，如果同步到 MongoDB 里面，如何解决新旧数据问题？(这里提到了一个公司实际业务问题，公司日志会存储到 MongoDB，如何保证每次存的都是最新的消息)</p>
<p>你知道哪些消息队列？这些消息队列有什么区别？</p>
<pre><code>Redis(简单的消息队列)
Kafka()
RocketMQ
</code></pre>
<p>软件设计<br>
有一个电商营销活动系统，你该如何去设计这个系统，保证系统不会出现问题？</p>
<p>项目中哪些地方用到了消息队列？是如何设计的？</p>
<ul>
<li>电商系统中，如何保证商品库存不会超卖问题？</li>
<li>如果一页面请求慢，该从哪些方面排查？
<ul>
<li>前端</li>
<li>网络</li>
<li>服务端代码</li>
<li>mysql查询速率</li>
</ul>
</li>
</ul>
<p><strong>1、事务四大特性</strong></p>
<p>原子性（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。</p>
<p>一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏 。</p>
<p>隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。</p>
<p>持久性（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。</p>
<p><strong>2、事务的并发问题</strong></p>
<p>脏读：事务 A 读取了事务 B 更新的数据，然后 B 回滚操作，那么 A 读取到的数据是脏数据</p>
<p>不可重复读：（事务 A 多次读取同一数据，事务 B 在事务 A 多次读取的过程中，对数据作了更新并提交，导致事务 A 多次读取同一数据时，结果 不一致。）（重点：数据修改）</p>
<p>幻读：系统管理员 A 将数据库中所有学生的成绩从具体分数改为 ABCDE 等级，但是系统管理员 B 就在这个时候插入了一条具体分数的记录，当系统管理员 A 改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。（重点：数据新增或删除）</p>
<p>小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表</p>
<p><strong>3、MySQL 事务隔离级别</strong></p>
<p>未提交读（READ UNCOMMITED）（没提交的数据可读，脏读，这些数据称为脏数据）</p>
<p>已提交读（READ COMMITED）（已提交的数据可读，不可重复读）</p>
<p>可重复读（RePEATABLE READ）一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</p>
<p>可串行化（SERIALIZABLE）（读操作会隐式获取共享锁，可以保证不同事务间的互斥，锁表，别想搞什么鬼，缺点也很明显，看到锁表你就懂的哈，效率问题）</p>
<p><strong>面试官问的面试题：</strong></p>
<p>1.php一些基础的数组使用，<br>
2.linux操作命令统计pv,uv这些，<br>
3.git命令的使用，<br>
4.redis如何实现延迟队列，分布式锁这些，<br>
5.php的结构，fpm配置这些。<br>
6.主要问对技术层面的把控度，比如如何设计高并发系统，需要考虑什么问题？可能会现在的问题，如何去预防，有什么方案处理？<br>
7.职业规划</p>
<p><strong>nginx:</strong><br>
epoll模型<br>
nginx和fpm的交互流程<br>
有哪些优化项<br>
负载均衡策略和对比<br>
限流</p>
<p><strong>mysql：</strong><br>
锁机制，索引，事务，隔离级别和对应解决的问题。<br>
sql查询优化，以及explain计划。<br>
mysql比较常见的细节问题，比如：innodb的特点，Hash索引和B+树区别，非聚簇索引和回表查询，以及写sql能力的考察。</p>
<p><strong>算法：</strong><br>
全排列，各种排序，二分查找。</p>
<p><strong>操作系统：</strong><br>
进程状态，IPC，调度算法，线程和协程，死锁。</p>
<p><strong>计算机网络：</strong><br>
五层分别哪些。tcp、udp区别。同源测略和跨域。<br>
一个网页从输入地址回车，到完整展示网页内容这段时间里，做了哪些工作。<br>
keepalived是什么，有什么作用（tcp）。<br>
cdn如何防篡改，https如何安全。</p>
<p><strong>Redis：</strong><br>
使用场景，淘汰策略，持久化，主从哨兵和底层实现。</p>
<p><strong>php：</strong><br>
zval结构，垃圾回收，7新特性，get|post，session，cookie，字符串，数组函数的用法，命名空间，composer<br>
fpm的优化，三种配置方式，静态方式如何确定最大worker数</p>
<p><strong>业务相关的问题：</strong><br>
接口设计，鉴权部分设计，单点，单用户，高并发，防超卖，Saas项目架构设计。</p>
<p><strong>开放式的问题:</strong><br>
请简单介绍一下你做的这个项目<br>
近期遇到比较棘手的问题、有挑战性的问题，你是如何去解决这个问题的。</p>
<ul>
<li>你在职期间做的最成功的一个项目是什么?</li>
</ul>
<h2 id="面试考点">面试考点</h2>
<ul>
<li>Javascript, jQuery以及Ajax</li>
<li>Linux基础知识</li>
<li>Mysql 数据库基础</li>
<li>程序设计</li>
<li>php框架基础知识</li>
<li>Mysql 基础知识考点</li>
<li>Mysql创建高性能的索引考察点</li>
<li>Mysql的SQL语句编写及优化</li>
<li>Mysql 的高可扩展和高可用及安全性</li>
<li>常见数据结构特征</li>
<li>算法的工作原理</li>
<li>时间复杂度</li>
<li>空间复杂度</li>
<li>其他逻辑算法</li>
<li>php内置函数实现</li>
<li>如何理解高并发
<ul>
<li>PV</li>
<li>UV</li>
<li>QPS</li>
</ul>
</li>
<li>优化时机
<ul>
<li>QPS阶段性优化</li>
</ul>
</li>
<li>优化案例
<ul>
<li>防盗链</li>
<li>减少http请求</li>
<li>浏览器缓存</li>
<li>cdn加速</li>
<li>数据库缓存</li>
<li>Mysql 的读写分离</li>
<li>分区及分库分表</li>
<li>LVS负载均衡</li>
</ul>
</li>
</ul>
<h3 id="真题">真题</h3>
<ul>
<li>
<p>什么是引用变量?在php中,用什么符号来定义引用变量?</p>
<pre><code>概念: &amp;
查看zval变量容器 xdebug_debug_zval($a)

is_ref   变量内存空间是否重新赋值
refcount    运用该空间的变量个数
</code></pre>
</li>
<li>
<p>说一下session与cookie的区别?</p>
<pre><code>因为http 是无状态的,前后没有联系,所以我们使用session进行会话控制.

Cookie:
  设置setcookie($name,$value,$expire,$domain);
  读取:$_COOKIE
  
  存贮不敏感重要信息
  不会占用服务器资源
  
Session:
  Session是基于cookie,session 是存储在服务器端.
  session_start();
  $_SESSION = []
  session_destroy();销毁
  
  
Cookie中存储了session_id,如果禁用掉的话,session_id无法正常传递.那么就要到url中去拼接或echo 常量SID

若会话多台服务器,那么我们将会把session存储到redis,memcache中
session_set_save_handler()

</code></pre>
</li>
<li>
<p>你是否使用过版本控制器?</p>
<pre><code>集中式
     都放在一台服务器中
分布式
</code></pre>
</li>
<li>
<p>Nginx + php-fpm</p>
<pre><code>cgi: 通用网关接口,是一种通信协议
fastcgi: 是cgi的升级版,保留进程,处理多个进程
php-fpm: fastcgi 的进程管理器,一般一个master进程,多个worker进程.master端口主要进行监听端口负责接收来自web的请求,worker进程解析请求.
</code></pre>
</li>
<li>
<p>php常见配置项</p>
<pre><code>register_globals      接收来自客户端的变量,默认关闭
allow_url_fopen      打开远程文件
allow_url_include    引用外部资源
date.timezone        设置时区
display_errors       bug展示
error_reporting      错误级别
safe_mode            安全模式
upload_max_filesize   最大上传文件大小
max_upload_file      最大上传文件数量
</code></pre>
</li>
<li>
<p>正则表达式考点</p>
<pre><code>至少写出一种验证139开头的正则表达式
preg_match();
preg_match_all();

正则表达式的作用: 分割,查找,匹配,替换字符串
分隔符:正斜线(/),hash符号(#)以及取反符号(~)
通用原子:
     \d, 数字0-9
     \D, 除了0-9
     \w, _
     \W, 除了_
     \s, 空白符
     \S  除了空白符
元字符: .    除了换行符外的任意符号
       *    匹配前面的内容出现一次或多次
       ?    零次或者一次
       ^    必须以它开头
       $    必须以他结尾
       +    出现一次及以上
       {n}  出现n次
       {n,} 大于n次
       {n,m}, 大于n次,小于m次
       []   集合,匹配括号内的字符集
       ()   
       [^]  取反,除了集合内的字符
       |    或者
       [-]  范围
       
模式修正符: 
        i  不区分大小写
        m  
        e
        s
        U
        x
        A
        D
        u
          
匹配中文: '/[x{4e00}-\x{9fa5}]+/u'
请写出以139开头的11位手机号码的正则表达式:
.*? 忽略中间元素

</code></pre>
</li>
<li>
<p>文件读取/写入操作</p>
<pre><code>fopen()函数
打开模式：
r  只读方式打开(文件指针指向开头)
r+ 读写方式打开
w  只写方式打开(会先清空文件)
w+ 读写方式打开(若文件不存在会创建文件)
a  追加的写入方式
a+ 读写的追加方式(将文件指针指向文件末尾)
x  以写入的方式打开(将文件指针指向文件开头)
x+ 

fread()  读取文件
fwrite() 写入文件
fclose() 关闭文件

写入函数 file_put_contents()
读取函数 file_get_contents()

访问远程文件
开启allow_url_fopen,

名称相关:basename(),dirname()
目录读取:opendir(),readdir(),closedir()
删除目录:rmdir()
目录创建:mkdir()
文件大小:filesize()
删除文件:unlink()
重命名文件或目录:rename()
文件属性:file_exists()
</code></pre>
</li>
<li>
<p>面向对象</p>
<ul>
<li>权限控制修饰符
<ul>
<li>public</li>
<li>protected</li>
<li>private</li>
</ul>
</li>
<li>封装继承多态</li>
</ul>
</li>
<li>
<p>网络协议</p>
<ul>
<li>
<p>HTTP状态码</p>
<ul>
<li>20x 响应成功</li>
<li>30x 重定向</li>
<li>40x 客户端错误</li>
<li>50x 服务端错误</li>
</ul>
</li>
<li>
<p>osi七层模型</p>
<ul>
<li>物理层</li>
<li>数据链路层</li>
<li>网络层</li>
<li>传输层</li>
<li>会话层</li>
<li>表示层</li>
<li>应用层</li>
</ul>
</li>
<li>
<p>http的工作特点及工作原理</p>
<ul>
<li>
<p>http 是无状态协议</p>
</li>
<li>
<p>基于B/S模式</p>
</li>
<li>
<p>通信开销小,简单快速</p>
</li>
<li>
<p>客户端发送给服务器,创建一个tcp连接,指定端口号为80,当服务器监听操到浏览器发送的请求将会进行分析解析然后返回.</p>
</li>
<li>
<p>http协议常见的请求头</p>
<ul>
<li>Content-Type</li>
<li>Accept</li>
<li>Origin</li>
<li>Cookie</li>
<li>Cache-Control</li>
</ul>
</li>
<li>
<p>http的请求方法</p>
<ul>
<li>GET     查找幂等资源</li>
<li>POST    创建资源</li>
<li>HEAD</li>
<li>OPTIONS</li>
<li>PUT     修改资源</li>
<li>DELETE    删除资源</li>
<li>TRACE</li>
</ul>
</li>
<li>
<p>GET与POST 的区别</p>
<ul>
<li>get可以收藏为书签</li>
<li>get可以在浏览器后退</li>
<li>get可以被缓存,post</li>
<li>get会存入历史</li>
<li>get会有长度限制,post则没有</li>
<li>post可以发送文件</li>
<li>post安全性更好</li>
</ul>
</li>
<li>
<p>常见网络协议及端口</p>
<ul>
<li>FTP        21</li>
<li>SFTP      22</li>
<li>Telnet   23</li>
<li>SMTP    24</li>
<li>HTTP     80</li>
<li>HTTPS   443</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>php数据类型</p>
<ul>
<li>标量
<ul>
<li>浮点    二进制运算中</li>
<li>布尔
<ul>
<li>0</li>
<li>0.0</li>
<li>' '</li>
<li>'0'</li>
<li>false</li>
<li>array()</li>
<li>null</li>
</ul>
</li>
<li>整形</li>
<li>字符串</li>
</ul>
</li>
<li>复合
<ul>
<li>数组
<ul>
<li>$GLOBALS</li>
<li>$_GET</li>
<li>$_POST</li>
<li>$_REQUEST</li>
<li>$_SERVER
<ul>
<li>$_SERVER['SERVER_ADDR']     请求IP地址</li>
<li>$_SERVER['SERVER_NAME']    请求服务器名称</li>
<li>$_SERVER['SERVER_TIME']      请求时间</li>
<li>$_SERVER['SERVER_QUERY']  请求参数</li>
<li>$_SERVER['REMOTE_ADDR']  客户端IP</li>
</ul>
</li>
<li>$_FILES</li>
<li>$_COOKIE</li>
<li>$_SESSION</li>
<li>$_ENV</li>
</ul>
</li>
<li>对象</li>
</ul>
</li>
<li>特殊
<ul>
<li>null</li>
</ul>
</li>
</ul>
</li>
<li>
<p>JavaScript 基本语法</p>
<ul>
<li>数据类型(JavaScript变量均为对象,当您声明一个变量时,就创建了一个新的对象)
<ul>
<li>字符串</li>
<li>数字</li>
<li>布尔</li>
<li>对象</li>
<li>数组</li>
<li>Null</li>
<li>Undefined</li>
</ul>
</li>
<li>创建对象
<ul>
<li>new Object()</li>
<li>使用对象构造器</li>
<li>var obj = {}</li>
</ul>
</li>
<li>运算符
<ul>
<li>使用+拼接</li>
</ul>
</li>
<li>Window对象</li>
<li>DOM对象
<ul>
<li>Document</li>
<li>Element</li>
<li>Attr</li>
<li>Event</li>
</ul>
</li>
</ul>
</li>
<li>
<p>jQuery 基本语法</p>
<ul>
<li>jQuery选择器
<ul>
<li>基本选择器</li>
<li>层次选择器</li>
<li>过滤选择器</li>
<li>可见性过滤选择器</li>
<li>属性过滤选择器</li>
<li>子元素过滤选择器</li>
<li>表单对象属性过滤选择器</li>
</ul>
</li>
<li>jQuery事件
<ul>
<li>$('button').click(function(){...some code...})</li>
<li>...</li>
</ul>
</li>
<li>jQuery效果
<ul>
<li>$('div').show</li>
<li>...</li>
</ul>
</li>
<li>jQuery DOM操作
<ul>
<li>属性</li>
<li>值</li>
<li>节点</li>
<li>css</li>
<li>尺寸</li>
</ul>
</li>
<li>jQuery常用Ajax操作
<ul>
<li>$.ajax()</li>
<li>$.get()</li>
<li>$.post()</li>
<li>$.getJSON()</li>
<li>$.getScript()</li>
</ul>
</li>
</ul>
</li>
<li>
<p>代码实例</p>
<ul>
<li>
<pre><code>- document.getElementById('test').className = 'good'
</code></pre>
</li>
<li>
<pre><code>- $('#test').className = 'good';
</code></pre>
</li>
<li>
<pre><code>- $(function(){
    $('#test').click(function(){
        
    })
})
</code></pre>
</li>
<li></li>
</ul>
</li>
<li>
<p>Mysql</p>
<ul>
<li>
<p>数据类型</p>
<ul>
<li>整数类型
<ul>
<li>TINYINT</li>
<li>SMALLINT</li>
<li>MEDIUMINT</li>
<li>INT</li>
<li>BIGINT</li>
</ul>
</li>
<li>实数类型
<ul>
<li>FLOAT</li>
<li>DOUBLE</li>
<li>DECIMAL(decimal可存储比bigint还大的整数)</li>
</ul>
</li>
<li>字符串类型
<ul>
<li>VARCHAR</li>
<li>CHAR</li>
<li>TEXT</li>
<li>BLOB</li>
</ul>
</li>
<li>枚举(避免使用数字作为ENUM的常量)</li>
<li>时间函数
<ul>
<li>TIMESTAMP(尽量使用这个)</li>
<li>DATETIME</li>
</ul>
</li>
</ul>
</li>
<li>
<p>常用操作</p>
<pre><code>mysql -u -p -h -P
</code></pre>
</li>
<li>
<p>Mysql数据表引擎</p>
<ul>
<li>
<p>InnoDB</p>
<ul>
<li>
<pre><code>- 默认事务型,最重要最广泛的存储引擎,性能优秀的数据存储在共享表空间.
- 读取数据时会在内存中构建hash索引
- 插入数据时会自动构建插入缓冲区
</code></pre>
</li>
<li>
<p>支持热备份</p>
</li>
<li>
<p>支持崩溃后安全修复</p>
</li>
<li>
<p>支持行级锁</p>
</li>
<li>
<p>支持外键</p>
</li>
<li>
<p>事务处理</p>
</li>
<li>
<p>数据存储在共享表空间</p>
</li>
</ul>
</li>
<li>
<p>MyISAM</p>
<ul>
<li>拥有全文索引,压缩,空间函数</li>
<li>不支持事务和行级锁,不支持安全恢复</li>
<li>表锁</li>
<li>支持全文索引</li>
<li>数据存储在MYD文件与MYI文件</li>
</ul>
</li>
<li>
<p>其他表引擎</p>
<ul>
<li>CSV</li>
<li>Memory</li>
</ul>
</li>
</ul>
</li>
<li>
<p>MySQL锁机制</p>
<ul>
<li>
<p>读锁</p>
<pre><code>- 
</code></pre>
</li>
<li>
<p>写锁</p>
</li>
<li>
<p>锁粒度</p>
<pre><code>表锁,系统性能开销最小,直接锁定整张表
行锁,
</code></pre>
</li>
</ul>
</li>
<li>
<p>MySQL索引</p>
<ul>
<li>
<p>类型</p>
<pre><code>- 主键索引
- 普通索引
- 唯一索引
- 联合索引
- 全文索引
</code></pre>
</li>
<li>
<p>影响</p>
<pre><code>减少服务器开销
将随机I/O变顺序I/O
提高查询速度,降低写入速度
</code></pre>
</li>
<li>
<p>场景</p>
<pre><code>- 对于非常小的表,直接全表扫描
</code></pre>
</li>
<li>
<p>注意</p>
<ul>
<li>复核索引遵循前缀原则</li>
<li>like查询,%不能在前,可以使用全文索引</li>
<li>column is null 可以使用索引</li>
<li>如果MySQL估计使用索引比全表扫描更慢,会放弃使用索引</li>
<li>如果or 前的条件中的列有索引,后面的没有,索引都不会被用到</li>
<li>列类型是字符串,查询时一定要给值加引号,否则索引失效</li>
</ul>
</li>
</ul>
</li>
<li>
<p>查询语句</p>
<ul>
<li>
<p>联合查询</p>
<pre><code>union 会合并重复的列
union all 会查询出所有的列

select * from a union select * from b
</code></pre>
</li>
<li>
<p>连表查询</p>
<ul>
<li>left join</li>
<li>inner join</li>
<li>right join</li>
</ul>
</li>
<li>
<p>嵌套查询</p>
<pre><code>select * from where id in (select id from b where ...)
</code></pre>
</li>
</ul>
</li>
<li>
<p>查询优化</p>
<ul>
<li>
<p>explain</p>
<ul>
<li></li>
</ul>
</li>
<li>
<p>show profiles</p>
<pre><code>set profiling =1;开启,服务器上执行的所有语句会检测消耗的时间,存到临时表
show profiles 查询执行sql日志
show profile for query 临时表ID

</code></pre>
</li>
<li>
<p>show status</p>
<pre><code>
</code></pre>
</li>
<li>
<p>show processlist</p>
<pre><code>查询是否有大量线程处于不正常的状态或特征
</code></pre>
</li>
<li>
<p>查询不需要的记录,使用limit解决</p>
</li>
<li>
<p>多表关联取出全部列, 少用select *</p>
</li>
<li>
<p>查询相同的数据,可以只用缓存</p>
</li>
<li>
<p>分解关联查询, 将关联语句差分为多条SQL来执行</p>
</li>
<li>
<p>优化limit 分页, 记录上次查询的id添加到where条件中</p>
</li>
<li>
<p>union all 的效率高于union</p>
</li>
</ul>
</li>
<li>
<p>分库分表</p>
<ul>
<li>当表数据达到百万或千万时需要进行分表</li>
</ul>
</li>
<li>
<p>算法的概念</p>
<ul>
<li>
<p>时间复杂度</p>
<pre><code>问题规模n的函数f(n),算法的时间复杂度记为T(n) = O(f(n))
随着n越大,算法执行的时间的增长率与f(n)的增长率正相关,称作为渐进时间复杂度

时间复杂度为循环递归次数

O(n^2)

O(1)

O(n)
</code></pre>
</li>
<li>
<p>空间复杂度</p>
<pre><code>算法需要消耗的内存空间,基座S(n) = O(f(n))
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>常见数据结构</p>
<ul>
<li>Array</li>
<li>LinkedList(链表)</li>
<li>Stack(栈,先进后出)</li>
<li>Heap(堆,二叉堆)</li>
<li>list(线性表)</li>
<li>queue(队列,先进先出)</li>
<li>doubly-linked-list(双向链表)</li>
<li>set(集合)</li>
<li>map(字典)</li>
<li>graph(图)</li>
</ul>
</li>
<li>
<p>真题</p>
<pre><code>//1,1,2,3,5,8,13,21,34,....

$arr = [1,1]

for($i=2;$i&lt;30;$i++){
    $arr[$i] = $arr[$i-1] + $arr[$i-2];
}

var_dump($arr[30]);
</code></pre>
<ul>
<li>
<p>请写一个函数,实现open_door转换为OpenDoor</p>
<pre><code>&lt;?php

function strHandle($str){
   $res = '';
   $arr = explode('_',$str);
   foreach($arr as $val){
     $res .= ucfirst($val)
   }
   return $res;
}
?&gt;
</code></pre>
</li>
<li>
<p>字符串反转</p>
<pre><code>&lt;?php

function str_rev($str)
{
   $i = 0;
   while(true){
      if(isset($str[$i])){
          break;
      }
      $i++
   }
   $res = '';
   for($j=$i-1;$j&gt;=0;$j--){
       $res = .= $str[$j];
   }
   return $res;
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>高并发和大流量解决方案</p>
<ul>
<li>
<p>php如何解决网站大流量与高并发</p>
<ul>
<li>高并发架构相关概念</li>
<li>高并发解决方案案例</li>
<li>QPS(每秒钟请求或者查询的数量,每秒响应请求数)</li>
<li>吞吐量:单位时间内处理的请求数量(通常由QPS与并发数决定)</li>
<li>响应时间:从请求发出到收到响应花费的时间.</li>
<li>PV(综合浏览量),及页面浏览量</li>
<li>UV(独立访客):一个用户一定时间内</li>
<li>日网站带宽 = PV / 统计时间(秒) * 平均页面大小 * 8</li>
<li>QPS为每秒钟HTTP请求数量</li>
<li>根据每天的QPS, 与 PV,来进行QPS测试,测试能承受的最大并发</li>
<li>ab -c 100 -n 5000  并发请求100次,总共请求5000次</li>
<li>注意: 不要对线上服务做压力测试</li>
</ul>
</li>
<li>
<p>QPS分析优化</p>
<ul>
<li>qps达到50, 一般的服务器可以应付</li>
<li>qps达到100, 1秒钟完成100次请求,但是我们不能保证数据库查询能完成100次,我们可以做一个数据库缓存, 数据库负载均衡</li>
<li>qps达到800, cdn加速, nginx负载均衡</li>
<li>qps达到1000, 让memcache 的请求远大于DB的请求, 静态HTML缓存</li>
<li>qps达到2000, 做业务分离,分布式存储.</li>
</ul>
</li>
<li>
<p>流量优化</p>
<ul>
<li>防盗链处理: 对于恶意请求, 减少外部使用服务器内部资源;</li>
<li>前端优化: 减少http请求,将css请求进行合并,添加异步请求.启用浏览器缓存和文件压缩,CDN加速</li>
<li>服务端优化: 页面静态化, 并发处理, 多进程, 多线程, 队列处理</li>
<li>数据库优化: 数据库缓存, redis缓存, 分库分表, 分区操作,读写分离,负载均衡</li>
<li>web服务器优化: 负载均衡, 反向代理</li>
</ul>
</li>
<li>
<p>防盗链</p>
<ul>
<li>在请求头referer 中加一个域名</li>
<li>在请求头中设立一个签名</li>
<li>Nginx 模块中ngx_http_referer_module 用来阻挡非法域名请求</li>
<li>当访问gif,jpg,png,flv等静态资源我们来验证请求源是否合法</li>
</ul>
</li>
<li>
<p>HTTP连接产生的开销</p>
<pre><code>域名解析--TCP连接--发送请求--等待--下载资源--解析时间
DNS 缓存
Keep-Alive
</code></pre>
</li>
<li>
<p>图片地图</p>
<pre><code>使图标的图片都在一张图片上
</code></pre>
</li>
<li>
<p>合并js,css</p>
</li>
<li>
<p>静态化,开启缓冲区</p>
</li>
<li>
<p>开启epoll模型</p>
</li>
<li>
<p>php高并发解决</p>
<pre><code>php 的swoole
mq
并发调度
</code></pre>
</li>
<li>
<p>mysql的查询缓存</p>
<pre><code>query_cache_type 为2 时即可使用查询缓存
query_cache_size 查询缓存预留的内存

</code></pre>
</li>
<li>
<p>nginx负责均衡策略</p>
<pre><code>功能强大,运行稳定
配置简单灵活
能够自动剔除工作不正常的后端服务器
上传文件使用异步模式
支持多重分配策略,可以分配权重,分配方式灵活

nginx策略
内置策略: IP Hash ,加权轮询
扩展策略: 

加权轮询策略: 首先将请求都分给高权重的机器
IP Hash策略: Nginx内置的另一个负载均衡

fair: 根据后端服务器的响应时间判断负载策略,选择最轻的机器进行分流

通用Hash ,一致性Hash策略

</code></pre>
<pre><code>http {
  upstream cluster {
     server srv1;
     server srv2;
     server srv3;
  }
  server {
    listen 80;
    location / {
       proxy_pass http://cluster
    }
  }
}
</code></pre>
</li>
</ul>
</li>
</ul>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95">模拟面试</a><br>
*
<ul>
<li><a href="#php">Php</a></li>
<li><a href="#mysql">Mysql</a></li>
<li><a href="#redis">Redis</a></li>
<li><a href="#docker">Docker</a></li>
<li><a href="#laravel">Laravel</a></li>
<li><a href="#http%E4%B8%8Enginx">http与nginx</a></li>
<li><a href="#kafka%E4%B8%8Erabbitmq">kafka与Rabbit<em>MQ</em></a></li>
<li><a href="#linux-%E4%B8%8E-shell">Linux 与 Shell</a></li>
<li><a href="#vue">Vue</a></li>
<li><a href="#golang">Golang</a></li>
<li><a href="#%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9">面试考点</a>
<ul>
<li><a href="#%E7%9C%9F%E9%A2%98">真题</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://wudengli.github.io/post/hello-friends/">
              <h3 class="post-title">
                Hello Friends
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '6543bdbd544d719f31cc',
    clientSecret: '54cca1ceaeacd3e1c06375b0ec7eeb7c1fb01d15',
    repo: 'JTX-comment',
    owner: 'best7l',
    admin: ['best7l'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://wudengli.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
